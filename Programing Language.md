# Programing Language
## 1. Introduction
### Reasons for studying programming languages
- Increased ability to express ideas
- Improved background for choosing appropriate languages
- Increased ability to learn new languages
- Better understanding of significance of implementation
- Better use of languages that are already known
### Programming domains
- Scientific applications, like **Fortran**; 
- Business applications, like **COBOL**
- Artificial intelligence, like **LISP**
- Systems programming, like **C**
- Web Software, like **php, javascript, html**
### [[ Language evaluation criteria]]
- **Readability**: the ease with which programs can be read and understood
- **Writability**: the ease with which a language can be used to create programs
- **Reliability**: conformance to specifications (i.e.,performs to its specifications)
- **Cost**: the ultimate total cost 
- **others**: like portability, Generality, Well-definedness 

### [[Influences on Language Design]]
- **Computer Architecture**
	- Languages are developed around the prevalent computer architecture, known as the **von Neumann architecture**
- **Program Design Methodologies**
	- New software development methodologies (e.g.,object-oriented software development) led to new programming paradigms and by extension, new programming languages
### Language categories

- **Imperative**
	- Central features are variables, assignment statements, and iteration
	- Include languages that support object-oriented programming
	- Include scripting languages
	- Include the visual languages
	- Examples: C, Java, Perl, JavaScript, Visual BASIC .NET, C++

- **Functional**
	- Main means of making computations is by applying functions to given parameters
	- Examples: LISP, Scheme, ML, F#
- **Logic**
	- Rule-based (rules are specified in no particular order)
		- Example: Prolog
- **Markup/programming hybrid**
	- Markup languages extended to support some programming
	- Examples: JSTL, XSLT
### Language design trade-offs
- **Reliability** vs. **cost of execution**
	- Example: Java demands all references to array elements be checked for proper indexing, which leads to increased execution costs

- **Readability** vs. **writability**
	- Example: APL provides many **powerful operators** (and a large number of **new** symbols), allowing complex computations to be written in a compact program but at the cost of poor **readability**

- **Writability (flexibility)** vs. **reliability**
	- Example: C++ pointers are powerful and very flexible but are unreliable
### [[Implementation Methods]]
- **Compilation**
	- Programs are translated into machine language; includes JIT systems
	- Use: Large commercial applications

- **Pure Interpretation**
	- Programs are interpreted by another program known as an interpreter
	- Use: Small programs or when efficiency is not an issue

- **Hybrid** Implementation Systems
	- A compromise between compilers and pure interpreters
	- Use: Small and medium systems when efficiency is not the first concern
## 2. Evolution of Major Programming Languages
### **Early History**
- **Plankalkül** (Konrad Zuse)
- **Fortran** (Formula Translation)
- **Algol** (Algorithmic Language)
- **COBOL** (Common Business Oriented Language)
### **Imperative Languages**
- **Fortran** (Scientific Applications)
- **Algol** (Structured Programming)
- **C** (System Programming)
- **Ada** (Military Applications)
- **BASIC** (Beginner-Friendly)9
###  **Functional Programming**

- **Lisp** (List Processing)
- **Scheme** (Lisp Derivative)
- **ML** (Meta-Language)
- **Haskell** (Lazy Evaluation)

### **Object-Oriented Languages**

- **Simula** (First OOP Language)
- **Smalltalk** (Pure Object-Oriented)
- **C++** (Object-Oriented Extension of C)
- **Java** (Platform Independence)
- **C#** (Microsoft's Language)

### **Scripting Languages**

- **Perl** (Text Processing)
- **Python** (General Purpose)
- **Ruby** (Web Development)
- **JavaScript** (Client-Side Web Development)
- **PHP** (Server-Side Web Development)

### **Language Evaluation Criteria**
- **Readability**
- **Writability**
- **Reliability**
- **Cost**
- **Efficiency**

  

##  **Syntax and Semantics**

  

- Lexical and syntactic structure

- Semantics

- Parsing

- BNF (Backus-Naur Form)

- Parse Trees

  

## ** Programming Paradigms**

  

- **Imperative Languages**

    - Examples: C, Java, Python

    - Characteristics: Sequence of statements, state changes

- **Functional Languages**

    - Examples: Haskell, Lisp

    - Characteristics: No state change, first-class functions

- **Logic Programming Languages**

    - Example: Prolog

    - Characteristics: Rule-based, declarative

- **Object-Oriented Programming**

    - Examples: Java, C++, Python

    - Key concepts: Encapsulation, inheritance, polymorphism

- **Scripting Languages**

    - Examples: Python, Ruby

    - Characteristics: Dynamic typing, scripting tasks

  

## **4. Data Types**

- Primitive data types

- Character strings

- User-defined types

- Type checking

- Strong vs weak typing

- Type coercion

## **5. Control Structures**

- Selection statements (if, switch)

- Iterative statements (loops)

- Unconditional branching (goto, break, continue)

- Exception handling

## **6. Subprograms and Functions**

- Subprogram definitions

- Parameter passing methods

- Activation records and call stack

- Recursion

- Coroutines and generators

## **7. Abstract Data Types and Encapsulation**

  

- Abstract Data Types (ADT)

- Data abstraction and encapsulation

- Modules and information hiding

- Interface vs implementation

  

## **8. Concurrency**

  

- Concurrency fundamentals

- Threads and processes

- Synchronization mechanisms

- Deadlock, race conditions

  

## **9. Exception Handling and Event Handling**

  

- Exception handling models

- Exceptions in different languages

- Event-driven programming

  

## **10. Functional Programming**

  

- Fundamentals of functional programming

- Functions as first-class objects

- Recursion

- Higher-order functions

  

## **11. Logic Programming**

  

- Logic programming basics

- Prolog syntax and semantics

- Backtracking and unification

- Rule-based systems

  

## **12. Memory Management**

  

- Heap and stack memory

- Garbage collection

- Memory leaks and management strategies

  

## **13. Programming Language Evaluation**

  

- Readability

- Writability

- Reliability

- Cost of maintenance

  

## **14. Latest Trends**

  

- New programming paradigms

- The rise of functional and logic programming languages

- Domain-specific languages (DSLs)

- Multi-paradigm languages